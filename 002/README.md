# 002

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

## Approach

This is actually a much simpler problem than it may first appear. The Fibonacci sequence grows quickly, and surpasses 4,000,000 after just 33 iterations. Additionally, the problem only requires summing the even-valued terms this sequence (which amounts to 11 out of the set of 32 numbers). The simplest method to generate Fibonacci numbers is to initialize two integer variables *a = 1* and *b = 2* and update them each round with *a' = b* and *b' = a+b*, where the primes denote the new values of the variables. Depending on the language, this may require an additional placeholder variable to store the value of either *a* or *b* before it is updated so the other variables can access the previous value (some languages, like Python and Julia allow simultaneous updating and avoid this issue).

To check for even status, we can simply apply the modulo operator with a divisor of 2 (exactly as in the approach for checking multiple status in problem 001). Another approach to check if a number is even is to make use of the bitwise AND operation (`odd & 1 = 1`, `even & 1 = 0`), this generally performs essentially the same as the modulo operation (in all solutions, both options were tested, and the faster one was kept). We can also avoid checking for 2 divisibility entirely by taking advantage of the fact that the Fibonacci series repeats the pattern of even, odd, odd, and simply sum every third value (starting from 2). The trade off here is that instead of performing a `x % 2 == 0` evaluation, we'll be executing an inner for loop to advance the iteration three rounds. In some cases (Python, C++) the modulo/AND method is slightly faster, in others (Julia, MATLAB) the inner loop method is optimal.

In theory, this problem could also benefit from the application of a temporary, lazy-evaluated iterator that provides a stream of values to be processed by another function (often with a single command). This approach is documented in the Python and Julia solutions, but ultimately proved to be slightly poorer in computation speed than direct iteration.

For this problem, there also exists an O(1) closed-form solution that makes use of the closed-form equations for the nth Fibonacci term and the sum of a geometric series. This process is demonstrated in `002_cf.py`. To utilize this strategy, determine the index at which the imposed limit is surpassed (which can be done by solving the nearest-integer variant of the Fibonacci equations for n). Next, apply the geometric sum equations and sum starting from index 3 and increasing in steps of 3 until the limit is reached. Note that the geometric sum equation assumes indexing from 0 and increasing in steps of 1. This can be attained by setting `n = 3(k + 1)`, which amounts to replacing the base of the exponential term with its cube and multiplying the sum with the same value.
